Input: nums = [1,0,2,0,3]
Output: 2
Explanation:
The only possible valid selections are the following:
Choose curr = 3, and a movement direction to the left.
[1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,1,0,3] -> [1,0,1,0,3] -> [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,0,0,2] -> [1,0,0,0,2] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,0].
Choose curr = 3, and a movement direction to the right.
[1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,2,0,2] -> [1,0,2,0,2] -> [1,0,1,0,2] -> [1,0,1,0,2] -> [1,0,1,0,1] -> [1,0,1,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [0,0,0,0,0].
#Hint:
Intuition....
sum_left --> sum of all elements in left to nums[i]
sum_right --> sum of all elements in right to nums[i]
when nums[i] ==0 and sum_right == sum_left : count+=2
when nums[i] ==0 and sum_right-1==sum_left : count +=1
when nums[i] == 0 and sum_right == sum_left-1 : count +=1
Hope you understand.. Thank you!

#code:
class Solution {
public:
    int countValidSelections(vector<int>& nums) {
        int n = nums.size();
        int total =0;
        for(auto i:nums){
            total += i;
        }
        
        int prefix=0;
        int cnt=0;
        for(int i=0; i<n; i++){
            prefix += nums[i];
            if(nums[i]==0 && prefix == total - prefix){
                cnt += 2;
            }else if(nums[i]==0 && prefix - 1 == total - prefix){
                cnt += 1;
            }else if(nums[i]==0 && prefix == total - prefix-1){
                cnt += 1;
            }
        }
        return cnt;
    }
};
